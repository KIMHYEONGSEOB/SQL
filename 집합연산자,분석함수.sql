--집합연산자
--UNION - 합집합(중복X)
--UNION ALL - 합집합(중복O)
--INTERSECT - 교집합
--MINUS -차집합

SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%';
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
--컬럼 개수가 일치해야 집합연산자 사용이 가능하다.

--UNION - 합집합(중복X)
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

--UNION ALL - 합집합(중복O)
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION ALL
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

--INTERSECT - 교집합
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
INTERSECT
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

--MINUS -차집합
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
MINUS
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

---------------------------------------------------------------------------------
--가상 테이블을 합쳐서 사용할 수도 있다.
SELECT 'PARK', 200 FROM DUAL
INTERSECT
SELECT 'KIM', 300 FROM DUAL
UNION ALL
SELECT 'CHOI', 400 FROM DUAL;

-------------------------------------------------------------------------------
--시험 단골 문제
--분석함수
SELECT FIRST_NAME,
       SALARY,
       RANK() OVER(ORDER BY SALARY DESC) AS 중복등수,
       DENSE_RANK() OVER(ORDER BY SALARY DESC) AS 중복없는등수,
       ROW_NUMBER() OVER(ORDER BY SALARY DESC) AS 일련번호,
       ROWNUM                    -- 정렬이 되면 순서가 바뀐다.
FROM EMPLOYEES;